package com.fermion.android.dagger_processor

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.DelicateKotlinPoetApi
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.TypeSpec
import java.io.File


class BuilderProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val options: Map<String, String>
) : SymbolProcessor {

    private var fileText = ""
    override fun process(resolver: Resolver): List<KSAnnotated> {
//        createTestFile(resolver)

        val componentPackageName = getDaggerAppComponentInjector(resolver)

        if (componentPackageName != "") {
            val viewFiles = getElements(
                resolver,
                InjectView::class.qualifiedName.orEmpty(),
                DaggerBaseView::class.simpleName.toString(),
            )
            var isFragmentFilesGenerated = false
            if (viewFiles.isNotEmpty()) {
                isFragmentFilesGenerated = genFragmentModuleFiles(viewFiles, componentPackageName)
            }

            val viewModelFiles = getElements(
                resolver,
                InjectViewModel::class.qualifiedName.orEmpty(),
                DaggerBaseViewModel::class.simpleName.toString(),
            )
            var isViewModuleFilesGenerated = false
            if (viewModelFiles.isNotEmpty()) {
                isViewModuleFilesGenerated = genViewModelFiles(viewModelFiles, componentPackageName)
            }

            if (isFragmentFilesGenerated || isViewModuleFilesGenerated) {
                genCommonModuleFile(componentPackageName)
            }
        }
        return emptyList()
    }

    private fun getDaggerAppComponentInjector(resolver: Resolver): String {
        var componentPackageName = ""
        resolver.getSymbolsWithAnnotation(
            DaggerAppComponent::class.qualifiedName.orEmpty(), inDepth = true
        ).filterIsInstance<KSClassDeclaration>().forEach {
//            componentPackageName = it.toClassName().packageName
            componentPackageName =
                getClassName(it, packageName = it.packageName.asString()).packageName
        }
        componentPackageName += ".generated"
        return componentPackageName;
    }


    private fun genCommonModuleFile(
        componentPackageName: String

    ) {
        var builderModules = mutableListOf<String>()
        if (fileExists(componentPackageName, "FragmentBuilderModule")) {
            builderModules.add("FragmentBuilderModule::class")
        }
        if (fileExists(componentPackageName, "ViewModelBuilderModule")) {
            builderModules.add("ViewModelBuilderModule::class")
        }
        val codeBlock = CodeBlock.of("includes=" + builderModules.toList().toString())
        deletedFile(componentPackageName, "CommonBuilderModule")
        FileSpec.builder(componentPackageName, "CommonBuilderModule")
            .addFileComment("this is a autogenerated code").addType(
                TypeSpec.interfaceBuilder("CommonBuilderModule").addAnnotation(
                    AnnotationSpec.builder(
                        ClassName(
                            "dagger", "Module"
                        )
                    ).addMember(codeBlock).build()

                ).addAnnotation(
                    AnnotationSpec.builder(
                        Suppress::class
                    ).addMember("%S", "unused").build()
                ).build()
            ).build().writeTo(
                File(options["projectPath"] ?: "")
            )
//            .writeTo(codeGenerator, Dependencies(false))
    }

    @Suppress("unused")
    private fun writeLogText(text: String) {
        fileText += "\n\n" + text
    }

    private fun writeFile(fileText: String) {
        try {
            val file = codeGenerator.createNewFile(
                dependencies = Dependencies.ALL_FILES,
                "com.fermion.example.cat_fact",
                "sample",
                extensionName = "txt"
            )

            file.write(fileText.toByteArray())
            file.close()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun genFragmentModuleFiles(
        fragmentModuleFiles: MutableList<KSClassDeclaration>, componentPackageName: String

    ): Boolean {
        try {
            val moduleFunctions = mutableListOf<FunSpec>()
            fragmentModuleFiles.forEach { fragmentFile ->
                val packageName = fragmentFile.packageName.asString()
                val simpleNames = getClassName(fragmentFile, packageName)
                val fileName = simpleNames.simpleName + "Module"
                moduleFunctions.add(
                    FunSpec.builder("contribute${fileName}").addAnnotation(
                        ClassName(
                            "dagger.android", "ContributesAndroidInjector"
                        )
                    ).addModifiers(KModifier.ABSTRACT)
                        .returns(
                            ClassName(
                                packageName,
                                simpleNames.simpleName
                            )
                        )
                        .build()
                )
            }
            deletedFile(componentPackageName, "FragmentBuilderModule")

            FileSpec.builder(componentPackageName, "FragmentBuilderModule")
                .addFileComment("this is a autogenerated code").addType(
                    TypeSpec.interfaceBuilder("FragmentBuilderModule").addAnnotation(
                        ClassName(
                            "dagger", "Module"
                        )
                    ).addAnnotation(
                        AnnotationSpec.builder(
                            Suppress::class
                        ).addMember("%S", "unused").build()
                    ).addFunctions(
                        moduleFunctions
                    ).build()
                ).build()
//                .writeTo(codeGenerator, Dependencies(false))
                .writeTo(
                    File(options["projectPath"] ?: "")
                )
            return true
        } catch (e: Exception) {
            logger.exception(e)
            return false
        }
    }

    private fun getClassName(
        fragmentFile: KSClassDeclaration,
        packageName: String
    ): ClassName {
        val typesString = checkNotNull(fragmentFile.qualifiedName).asString()
            .removePrefix("$packageName.")
        val simpleNames = ClassName(
            packageName, typesString
                .split(".")
        )
        return simpleNames
    }


    private fun genViewModelFiles(
        viewModelFiles: MutableList<KSClassDeclaration>, componentPackageName: String

    ): Boolean {
        try {
            val moduleFunctions = mutableListOf<FunSpec>()
            viewModelFiles.forEach { viewModelFile ->
                val simpleNames = getClassName(viewModelFile, viewModelFile.packageName.asString())
                val fileName = simpleNames.simpleName + "Module"
                moduleFunctions.add(
                    FunSpec.builder("binds${fileName}").addParameter(
                        ParameterSpec.builder(
                            simpleNames.simpleName.camelCase(), simpleNames
                        ).build()
                    ).addAnnotation(
                        ClassName(
                            "dagger", "Binds"
                        )
                    ).addAnnotation(
                        ClassName(
                            "dagger.multibindings", "IntoMap"
                        )
                    ).addAnnotation(
                        AnnotationSpec.builder(
                            ClassName(
                                "com.fermion.android.base.di", "ViewModelKey"
                            )
                        ).addMember("${simpleNames.simpleName}::class").build()

                    ).addModifiers(KModifier.ABSTRACT)
                        .returns(ClassName("androidx.lifecycle", "ViewModel")).build()
                )
            }

            deletedFile(componentPackageName, "ViewModelBuilderModule")
            FileSpec.builder(componentPackageName, "ViewModelBuilderModule")
                .addFileComment("this is a autogenerated code").addType(
                    TypeSpec.interfaceBuilder("ViewModelBuilderModule").addAnnotation(
                        ClassName(
                            "dagger", "Module"
                        )
                    ).addAnnotation(
                        AnnotationSpec.builder(
                            Suppress::class
                        ).addMember("%S", "unused").build()
                    ).addFunctions(
                        moduleFunctions
                    ).build()
                ).build()
//                .writeTo(codeGenerator, Dependencies(false))
                .writeTo(
                    File(options["projectPath"] ?: "")
                )
//                .writeTo(codeGenerator, Dependencies(true))
            return true
        } catch (e: Exception) {
            return false
        }
    }


    private fun fileExists(componentPackageName: String, fileName: String): Boolean {
        if (options["projectPath"] != null) {
            val projectFile = File(options["projectPath"] ?: "")
            val folderPackage = componentPackageName.replace(".", "/")
            val diFolder =
                File(projectFile.absolutePath + "\\" + folderPackage + "\\${fileName}.kt")
            return diFolder.exists()

        } else {
            return false
        }
    }

    private fun deletedFile(componentPackageName: String, fileName: String) {
        if (options["projectPath"] != null) {
            val projectFile = File(options["projectPath"] ?: "")
            val folderPackage = componentPackageName.replace(".", "/")
            val diFolder =
                File(projectFile.absolutePath + "\\" + folderPackage + "\\${fileName}.kt")
            if (diFolder.exists()) {
                diFolder.delete()
            }
        }
    }

    private fun String.camelCase(): String {
        return this.replaceFirst(this.first(), this.first().lowercaseChar())
    }

    @OptIn(DelicateKotlinPoetApi::class)
    private fun getElements(
        resolver: Resolver,
        annotationName: String,
        superClassAnnotation: String,
    ): MutableList<KSClassDeclaration> {
        val result = mutableListOf<KSClassDeclaration>()
        resolver.getSymbolsWithAnnotation(annotationName, inDepth = true)
            .filterIsInstance<KSClassDeclaration>().forEach { ksClassDeclaration ->
                ksClassDeclaration.superTypes.forEach { it ->
                    it.resolve().declaration.annotations.forEach {
                        if (it.annotationType.toString() == superClassAnnotation) {
                            result.add(ksClassDeclaration)
                        }
                    }
                }
            }

        return result;

    }


}